(defun mulEach(l1 l2)
  (cond
      ((and (atom l1) (atom l2)) (list(* l1 l2)))
      (t (apply #'append (MAPCAR #'mulEach l1 l2)))
  )
)

(defun mainMat(m1 m2)
  (cond 
      ((and (atom m1) (atom m2)) nil)
      ((and (listp m1) (listp m2)) (append (mulEach m1 m2) (apply #'append (MAPCAR #'mainMat m1 m2))))
      (t (MAPCAR #'mainMat m1 m2))
   )
)

(defun atomsRev(l)
  (cond
      ((atom l) (list l))
      (t (MAPCAN #'atomsRev(reverse l)))
  )
)

(defun nrOcc(e l)
  (cond
       ((equal l e) 1)
       ((atom l) 0)
       (t (apply #'+ (MAPCAR #'(LAMBDA(l) (nrOcc e l)) l)))
   )
)

(defun nrap(e L)
  (cond 
      ((equal L e) 1) 
      ((atom L) 0) 
      (t (apply #'+ (mapcar #'(lambda(L) (nrap e L) )l ) ))
  )
)

(defun atomsDepthN(n l)
  (cond
      ;((and (= n 0) (atom l)) (list l))
      ;((= n 0) nil)
      ;((atom l) nil)
      ;(t (MAPCAN #'(LAMBDA(l) (atomsDepthN (- n 1) l)) l))
      ((and (= n 0) (atom L)) (list L))
      ((= n 0) nil) 
      ((atom L) nil) 
      (t (mapcan #'(lambda(l) (atomsDepthN (- n 1) l)) l))
   )
)

(defun lista(L n)
 (cond 
   ((and (= n 0) (atom L)) (list L))
   ((= n 0) nil) 
   ((atom L) nil)
   (t (mapcan #'(lambda(L) (lista L (- n 1))) L))
)
)

(defun subm(L) 
  (cond 
      ((null L) (list nil)) 
      (t ((lambda (s) (append s (mapcar #'(lambda (sb) (cons (car L) sb)) s))) (subm(cdr L) )) 
   )
)
)

(defun permutari(L)
  (cond
     ((null (cdr L)) (list L))
     (t (mapcan #'(lambda (e) (mapcar #'(lambda (p) (cons e p) ) (permutari(remove e L)) )) L ))
 )
) 