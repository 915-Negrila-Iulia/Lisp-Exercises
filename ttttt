(defun addNtoN(l e p n)
  (cond
      ((null l) nil)
      ((equal 0 (mod p n)) (cons e (addNtoN l e (+ 1 p) n)))
      (t (cons (car l) (addNtoN (cdr l) e (+ 1 p) n)))
   )
)

(defun mainAddNtoN (l e n)
      (addNtoN l e 1 n) 
)

(defun evenLevel(l lvl)
  (cond
      ((and (atom l) (= (mod lvl 2) 0)) 1)
      ((atom l) 0)
      (t (apply #'+ (mapcar #'(lambda(l)(evenLevel l (+ 1 lvl))) l)))
   )
)

(defun main(l)
  (evenLevel l 0)
)


(defun atomList(l)
  (cond
      ((numberp l) (list l))
      ((atom l) nil)
      (t (apply #'append(MAPCAR #'atomList l)))
   )
)

(defun checkFirst(l)
  (cond 
      ((null l) nil)
      ((null (atomList l)) nil)
      ((= (car (atomList l)) 5) T)
      (T nil)
  )
)

(defun nrSub(l)
  (cond
      ((atom l) 0)
      ((checkFirst l) (+ 1 (apply #'+ (MAPCAR #'nrSub l))))
      (t (apply #'+ (MAPCAR #'nrSub l)))
   )
)

(defun isMember(l e)
  (cond 
      ((and (atom l) (equal l e)) t)
      ((atom l) nil)
      (t (SOME #'IDENTITY (MAPCAR #'(lambda(l)(isMember l e)) l)))
   )
)

(defun allEqual(l e)
  (cond
      ((and (atom l) (equal l e)) t)
      ((atom l) nil)
      (t (EVERY #'IDENTITY (MAPCAR #'(lambda(l)(allEqual l e)) l)))
   )
)